from typing import Overload, List, Tuple


class ConceptDenotation:
    def to_sorted_vector(self) -> List[int]: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...


class RoleDenotation:
    def to_sorted_vector(self) -> List[Tuple[int, int]]: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...


class DenotationsCaches:
    def __init__(self) -> None: ...


class Constant:
    def __eq__(self, other: "Constant") -> bool: ...
    def __neq__(self, other: "Constant") -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def get_index(self) -> int: ...
    def get_name(self) -> str: ...


class Predicate:
    def __eq__(self, other: "Predicate") -> bool: ...
    def __neq__(self, other: "Predicate") -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def get_index(self) -> int: ...
    def get_name(self) -> str: ...
    def get_arity(self) -> int: ...
    def is_static(self) -> bool: ...


class VocabularyInfo:
    def add_predicate(self, name: str, arity: int, is_static: bool) -> Predicate: ...
    def add_constant(self, name: str) -> Constant: ...
    def get_predicates(self) -> List[Predicate]: ...
    def get_constants(self) -> List[Constant]: ...
    def get_predicate(self, name: str) -> Predicate: ...
    def get_constant(self, name: str) -> Constant: ...


class Object:
    def __eq__(self, other: "Object") -> bool: ...
    def __neq__(self, other: "Object") -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def get_index(self) -> int: ...
    def get_name(self) -> str: ...


class Atom:
    def __eq__(self, other: "Atom") -> bool: ...
    def __neq__(self, other: "Atom") -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def get_index(self) -> int: ...
    def get_name(self) -> str: ...
    def get_predicate_index(self) -> int: ...
    def get_object_indices(self) -> List[int]: ...
    def is_static(self) -> bool: ...


class InstanceInfo:
    def __init__(self, vocabulary: VocabularyInfo, index: int = -1) -> None: ...
    def add_object(self, name: str) -> Object: ...
    @overload
    def add_atom(self, predicate: Predicate, objects: List[Object]) -> Atom: ...
    @overload
    def add_atom(self, predicate_name: str, object_names: List[str]) -> Atom: ...
    @overload
    def add_atom(self, predicate_index: int, object_indices: List[int]) -> Atom: ...
    @overload
    def add_static_atom(self, predicate: Predicate, objects: List[Object]) -> Atom: ...
    @overload
    def add_static_atom(self, predicate_name: str, object_names: List[str]) -> Atom: ...
    @overload
    def add_static_atom(self, predicate_index: int, object_indices: List[int]) -> Atom: ... 
    def set_index(self, index: int) -> None: ...
    def get_index(self) -> int: ...
    def get_objects(self) -> List[Object]: ...
    def get_atoms(self) -> List[Atom]: ...
    def get_static_atoms(self) -> List[Atom]: ...
    def get_object(self, object_name: str) -> Object: ...
    def get_atom(self, atom_name: str) -> Atom: ...
    def get_vocabulary_info(self): VocabularyInfo: ...


class State:
    def __eq__(self, other: "State") -> bool: ...
    def __neq__(self, other: "State") -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...
    def set_index(self, index: int) -> None: ...
    def get_index(self) -> int: ...
    def get_atom_indices(self): List[int]: ...
    def get_instance_info(self): InstanceInfo: ...


class BaseElement:
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def compute_complexity(self) -> int: ...
    def compute_repr(self) -> str: ...
    def set_index(self, index: int) -> None: ...
    def get_index(self) -> int: ...
    def get_vocabulary_info(self): VocabularyInfo: ...


class Concept(BaseElement):
    @overload 
    def evaluate(self, state: State) -> ConceptDenotation: ...
    @overload 
    def evaluate(self, state: State, denotations_caches: DenotationsCaches) -> ConceptDenotation: ...
    @overload 
    def evaluate(self, states: List[State], denotations_caches: DenotationsCaches) -> List[ConceptDenotation]: ...


class Role(BaseElement):
    @overload 
    def evaluate(self, state: State) -> RoleDenotation: ...
    @overload 
    def evaluate(self, state: State, denotations_caches: DenotationsCaches) -> RoleDenotation: ...
    @overload 
    def evaluate(self, states: List[State], denotations_caches: DenotationsCaches) -> List[RoleDenotation]: ...


class Boolean(BaseElement):
    @overload 
    def evaluate(self, state: State) -> bool: ...
    @overload 
    def evaluate(self, state: State, denotations_caches: DenotationsCaches) -> bool: ...
    @overload 
    def evaluate(self, states: List[State], denotations_caches: DenotationsCaches) -> List[bool]: ...


class Numerical(BaseElement):
    @overload 
    def evaluate(self, state: State) -> int: ...
    @overload 
    def evaluate(self, state: State, denotations_caches: DenotationsCaches) -> int: ...
    @overload 
    def evaluate(self, states: List[State], denotations_caches: DenotationsCaches) -> List[int]: ...


class SyntacticElementFactory:
    def __init__(self, vocabulary: VocabularyInfo) -> None: ...
    def parse_concept(self, description: str) -> Concept: ...
    def parse_role(self, description: str) -> Role: ...
    def parse_boolean(self, description: str) -> Boolean: ...
    def parse_numerical(self, description: str) -> Numerical: ...
    @overload 
    def make_empty_boolean(self, concept: Concept) -> Boolean: ...
    @overload 
    def make_empty_boolean(self, role: Role) -> Boolean: ...
    @overload 
    def make_inclusion_boolean(self, concept_left: Concept, concept_right: Concept) -> Boolean: ...
    @overload 
    def make_inclusion_boolean(self, role_left: Role, role_right: Concept) -> Boolean: ...
    def make_nullary_boolean(self, predicate: Predicate) -> Boolean: ...


        #.def("make_all_concept", &SyntacticElementFactory::make_all_concept, py::arg("role"), py::arg("concept"))
        #.def("make_and_concept", &SyntacticElementFactory::make_and_concept, py::arg("concept_left"), py::arg("concept_right"))
        #.def("make_bot_concept", &SyntacticElementFactory::make_bot_concept)
        #.def("make_diff_concept", &SyntacticElementFactory::make_diff_concept, py::arg("concept_left"), py::arg("concept_right"))
        #.def("make_equal_concept", &SyntacticElementFactory::make_equal_concept, py::arg("role_left"), py::arg("role_right"))
        #.def("make_not_concept", &SyntacticElementFactory::make_not_concept, py::arg("concept"))
        #.def("make_one_of_concept", &SyntacticElementFactory::make_one_of_concept, py::arg("constant"))
        #.def("make_or_concept", &SyntacticElementFactory::make_or_concept, py::arg("concept_left"), py::arg("concept_right"))
        #.def("make_projection_concept", &SyntacticElementFactory::make_projection_concept, py::arg("role"), py::arg("pos"))
        #.def("make_primitive_concept", &SyntacticElementFactory::make_primitive_concept, py::arg("predicate"), py::arg("pos"))
        #.def("make_some_concept", &SyntacticElementFactory::make_some_concept, py::arg("role"), py::arg("concept"))
        #.def("make_subset_concept", &SyntacticElementFactory::make_subset_concept, py::arg("concept_left"), py::arg("concept_right"))
        #.def("make_top_concept", &SyntacticElementFactory::make_top_concept)
#
        #.def("make_concept_distance_numerical", &SyntacticElementFactory::make_concept_distance_numerical, py::arg("concept_from"), py::arg("role"), py::arg("concept_to"))
        #.def("make_count_numerical", py::overload_cast<const std::shared_ptr<const Concept>&>(&SyntacticElementFactory::make_count_numerical), py::arg("concept"))
        #.def("make_count_numerical", py::overload_cast<const std::shared_ptr<const Role>&>(&SyntacticElementFactory::make_count_numerical), py::arg("role"))
        #.def("make_role_distance_numerical", &SyntacticElementFactory::make_role_distance_numerical, py::arg("role_from"), py::arg("role"), py::arg("role_to"))
        #.def("make_sum_concept_distance_numerical", &SyntacticElementFactory::make_sum_concept_distance_numerical, py::arg("concept_from"), py::arg("role"), py::arg("concept_to"))
        #.def("make_sum_role_distance_numerical", &SyntacticElementFactory::make_sum_role_distance_numerical, py::arg("role_from"), py::arg("role"), py::arg("role_to"))
#
        #.def("make_and_role", &SyntacticElementFactory::make_and_role, py::arg("role_left"), py::arg("role_right"))
        #.def("make_compose_role", &SyntacticElementFactory::make_compose_role, py::arg("role_left"), py::arg("role_right"))
        #.def("make_diff_role", &SyntacticElementFactory::make_diff_role, py::arg("role_left"), py::arg("role_right"))
        #.def("make_identity_role", &SyntacticElementFactory::make_identity_role, py::arg("concept"))
        #.def("make_inverse_role", &SyntacticElementFactory::make_inverse_role, py::arg("role"))
        #.def("make_not_role", &SyntacticElementFactory::make_not_role, py::arg("role"))
        #.def("make_or_role", &SyntacticElementFactory::make_or_role, py::arg("role_left"), py::arg("role_right"))
        #.def("make_primitive_role", &SyntacticElementFactory::make_primitive_role, py::arg("role"), py::arg("pos_1"), py::arg("pos_2"))
        #.def("make_restrict_role", &SyntacticElementFactory::make_restrict_role, py::arg("role"), py::arg("concept"))
        #.def("make_top_role", &SyntacticElementFactory::make_top_role)
        #.def("make_transitive_closure", &SyntacticElementFactory::make_transitive_closure, py::arg("role"))
        #.def("make_transitive_reflexive_closure", &SyntacticElementFactory::make_transitive_reflexive_closure, py::arg("role"))

    def get_vocabulary_info(self): VocabularyInfo: ...